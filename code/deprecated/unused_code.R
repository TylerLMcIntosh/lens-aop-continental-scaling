


####################
######### Non-WALK2 calls

# 
# tic()
# conus_lens_analysis(region_polygons_merged = region_polygons_merged,
#                     areas_of_interest_merged = areas_of_interest_merged,
#                     raster = raster,
#                     raster_cat_df = raster_cats,
#                     run_name = "neon_domains_evt_raw_all_0001",
#                     cat_base_column_name = "VALUE",
#                     aoi_drop_perc = 0.001,
#                     drop_classes = NA,
#                     drop_classes_column_name = NA,
#                     out_rast_values = "BOTH",
#                     out_rast_type = "BOTH",
#                     out_dir = here::here('data/derived/'))
# toc()
# 
# conus_lens_analysis(region_polygons_merged = region_polygons_merged,
#                     areas_of_interest_merged = areas_of_interest_merged,
#                     raster = raster,
#                     raster_cat_df = raster_cats,
#                     run_name = "neon_domains_evt_raw_all_001",
#                     cat_base_column_name = "VALUE",
#                     aoi_drop_perc = 0.01,
#                     drop_classes = NA,
#                     drop_classes_column_name = NA,
#                     out_rast_values = "BOTH",
#                     out_rast_type = "BOTH",
#                     out_dir = here::here('data/derived/'))
# 
# conus_lens_analysis(region_polygons_merged = region_polygons_merged,
#                     areas_of_interest_merged = areas_of_interest_merged,
#                     raster = raster,
#                     raster_cat_df = raster_cats,
#                     run_name = "neon_domains_evt_raw_all_01",
#                     cat_base_column_name = "VALUE",
#                     aoi_drop_perc = 0.1,
#                     drop_classes = NA,
#                     drop_classes_column_name = NA,
#                     out_rast_values = "BOTH",
#                     out_rast_type = "BOTH",
#                     out_dir = here::here('data/derived/'))
# 
# tic()
# conus_lens_analysis(region_polygons_merged = region_polygons_merged,
#                     areas_of_interest_merged = areas_of_interest_merged,
#                     raster = raster,
#                     raster_cat_df = raster_cats,
#                     run_name = "neon_domains_evt_raw_all_1",
#                     cat_base_column_name = "VALUE",
#                     aoi_drop_perc = 1,
#                     drop_classes = NA,
#                     drop_classes_column_name = NA,
#                     out_rast_values = "BOTH",
#                     out_rast_type = "BOTH",
#                     out_dir = here::here('data/derived/'))
# toc()






# conus_lens_analysis(region_polygons_merged = region_polygons_merged,
#                     areas_of_interest_merged = areas_of_interest_merged,
#                     raster = raster,
#                     raster_cat_df = raster_cats,
#                     run_name = "neon_domains_evt_raw_no_ag_dev_mine_0001",
#                     cat_base_column_name = "VALUE",
#                     aoi_drop_perc = 0.001,
#                     drop_classes = ag_dev_mine_evt_names,
#                     drop_classes_column_name = "EVT_NAME",
#                     out_rast_values = "BOTH",
#                     out_rast_type = "BOTH",
#                     out_dir = here::here('data/derived/'))
# 
# conus_lens_analysis(region_polygons_merged = region_polygons_merged,
#                     areas_of_interest_merged = areas_of_interest_merged,
#                     raster = raster,
#                     raster_cat_df = raster_cats,
#                     run_name = "neon_domains_evt_raw_no_ag_dev_mine_001",
#                     cat_base_column_name = "VALUE",
#                     aoi_drop_perc = 0.01,
#                     drop_classes = ag_dev_mine_evt_names,
#                     drop_classes_column_name = "EVT_NAME",
#                     out_rast_values = "BOTH",
#                     out_rast_type = "BOTH",
#                     out_dir = here::here('data/derived/'))
# 
# conus_lens_analysis(region_polygons_merged = region_polygons_merged,
#                     areas_of_interest_merged = areas_of_interest_merged,
#                     raster = raster,
#                     raster_cat_df = raster_cats,
#                     run_name = "neon_domains_evt_raw_no_ag_dev_mine_01",
#                     cat_base_column_name = "VALUE",
#                     aoi_drop_perc = 0.1,
#                     drop_classes = ag_dev_mine_evt_names,
#                     drop_classes_column_name = "EVT_NAME",
#                     out_rast_values = "BOTH",
#                     out_rast_type = "BOTH",
#                     out_dir = here::here('data/derived/'))
# 
# conus_lens_analysis(region_polygons_merged = region_polygons_merged,
#                     areas_of_interest_merged = areas_of_interest_merged,
#                     raster = raster,
#                     raster_cat_df = raster_cats,
#                     run_name = "neon_domains_evt_raw_no_ag_dev_mine_1",
#                     cat_base_column_name = "VALUE",
#                     aoi_drop_perc = 1,
#                     drop_classes = ag_dev_mine_evt_names,
#                     drop_classes_column_name = "EVT_NAME",
#                     out_rast_values = "BOTH",
#                     out_rast_type = "BOTH",
#                     out_dir = here::here('data/derived/'))



# 
# conus_lens_analysis(region_polygons_merged = region_polygons_merged,
#                     areas_of_interest_merged = areas_of_interest_merged,
#                     raster = raster,
#                     raster_cat_df = raster_cats,
#                     run_name = "neon_domains_evt_groups_all_0001",
#                     cat_base_column_name = "EVT_GP",
#                     aoi_drop_perc = 0.001,
#                     drop_classes = NA,
#                     drop_classes_column_name = NA,
#                     out_rast_values = "BOTH",
#                     out_rast_type = "BOTH",
#                     out_dir = here::here('data/derived/'))
# 
# conus_lens_analysis(region_polygons_merged = region_polygons_merged,
#                     areas_of_interest_merged = areas_of_interest_merged,
#                     raster = raster,
#                     raster_cat_df = raster_cats,
#                     run_name = "neon_domains_evt_groups_all_001",
#                     cat_base_column_name = "EVT_GP",
#                     aoi_drop_perc = 0.01,
#                     drop_classes = NA,
#                     drop_classes_column_name = NA,
#                     out_rast_values = "BOTH",
#                     out_rast_type = "BOTH",
#                     out_dir = here::here('data/derived/'))
# 
# conus_lens_analysis(region_polygons_merged = region_polygons_merged,
#                     areas_of_interest_merged = areas_of_interest_merged,
#                     raster = raster,
#                     raster_cat_df = raster_cats,
#                     run_name = "neon_domains_evt_groups_all_01",
#                     cat_base_column_name = "EVT_GP",
#                     aoi_drop_perc = 0.1,
#                     drop_classes = NA,
#                     drop_classes_column_name = NA,
#                     out_rast_values = "BOTH",
#                     out_rast_type = "BOTH",
#                     out_dir = here::here('data/derived/'))
# 
# tic()
# conus_lens_analysis(region_polygons_merged = region_polygons_merged,
#                     areas_of_interest_merged = areas_of_interest_merged,
#                     raster = raster,
#                     raster_cat_df = raster_cats,
#                     run_name = "neon_domains_evt_groups_all_1",
#                     cat_base_column_name = "EVT_GP",
#                     aoi_drop_perc = 1,
#                     drop_classes = NA,
#                     drop_classes_column_name = NA,
#                     out_rast_values = "BOTH",
#                     out_rast_type = "BOTH",
#                     out_dir = here::here('data/derived/'))
# toc()



# conus_lens_analysis(region_polygons_merged = region_polygons_merged,
#                     areas_of_interest_merged = areas_of_interest_merged,
#                     raster = raster,
#                     raster_cat_df = raster_cats,
#                     run_name = "neon_domains_evt_groups_no_ag_dev_mine_0001",
#                     cat_base_column_name = "EVT_GP",
#                     aoi_drop_perc = 0.001,
#                     drop_classes = ag_dev_mine_evt_names,
#                     drop_classes_column_name = "EVT_NAME",
#                     out_rast_values = "BOTH",
#                     out_rast_type = "BOTH",
#                     out_dir = here::here('data/derived/'))
# 
# conus_lens_analysis(region_polygons_merged = region_polygons_merged,
#                     areas_of_interest_merged = areas_of_interest_merged,
#                     raster = raster,
#                     raster_cat_df = raster_cats,
#                     run_name = "neon_domains_evt_groups_no_ag_dev_mine_001",
#                     cat_base_column_name = "EVT_GP",
#                     aoi_drop_perc = 0.01,
#                     drop_classes = ag_dev_mine_evt_names,
#                     drop_classes_column_name = "EVT_NAME",
#                     out_rast_values = "BOTH",
#                     out_rast_type = "BOTH",
#                     out_dir = here::here('data/derived/'))
# 
# conus_lens_analysis(region_polygons_merged = region_polygons_merged,
#                     areas_of_interest_merged = areas_of_interest_merged,
#                     raster = raster,
#                     raster_cat_df = raster_cats,
#                     run_name = "neon_domains_evt_groups_no_ag_dev_mine_01",
#                     cat_base_column_name = "EVT_GP",
#                     aoi_drop_perc = 0.1,
#                     drop_classes = ag_dev_mine_evt_names,
#                     drop_classes_column_name = "EVT_NAME",
#                     out_rast_values = "BOTH",
#                     out_rast_type = "BOTH",
#                     out_dir = here::here('data/derived/'))
# 
# conus_lens_analysis(region_polygons_merged = region_polygons_merged,
#                     areas_of_interest_merged = areas_of_interest_merged,
#                     raster = raster,
#                     raster_cat_df = raster_cats,
#                     run_name = "neon_domains_evt_groups_no_ag_dev_mine_1",
#                     cat_base_column_name = "EVT_GP",
#                     aoi_drop_perc = 1,
#                     drop_classes = ag_dev_mine_evt_names,
#                     drop_classes_column_name = "EVT_NAME",
#                     out_rast_values = "BOTH",
#                     out_rast_type = "BOTH",
#                     out_dir = here::here('data/derived/'))





# 
# #################
############## TESTING GROUPING WITH OTHER COLUMN NAME
# 
# 
# activeCat(raster) <- "Value"
# 
# taoi <- areas_of_interest[1,]
# tregion <- taoi |> sf::st_buffer(1000)
# tregion_rast <- crop_careful_universal(raster, tregion, mask = TRUE)
# taoi_rast<- crop_careful_universal(raster, taoi, mask = TRUE)
# 
# 
# tic()
# test <- representative_categorical_cover_analysis(raster = raster,
#                                                   raster_cat_df = raster_cats,
#                                                   region_shape = tregion,
#                                                   aoi_shape = taoi,
#                                                   run_name = "TESTSMALL",
#                                                   cat_base_column_name = "VALUE",
#                                                   drop_classes = NA,
#                                                   drop_classes_column_name = NA,
#                                                   region_drop_perc = NA,
#                                                   out_rast_values = "PERC_COVER",
#                                                   out_rast_type = "NOT_REP",
#                                                   aoi_drop_perc = 3,
#                                                   out_dir = dir_representative,
#                                                   new_sub_dir = FALSE)
# toc()
# 
# test2  <- representative_categorical_cover_analysis(raster = raster,
#                                                     raster_cat_df = raster_cats,
#                                                     region_shape = tregion,
#                                                     aoi_shape = taoi,
#                                                     run_name = "TESTSMALL",
#                                                     cat_base_column_name = "EVT_GP",
#                                                     drop_classes = NA,
#                                                     drop_classes_column_name = NA,
#                                                     region_drop_perc = NA,
#                                                     out_rast_values = "PERC_COVER",
#                                                     out_rast_type = "NOT_REP",
#                                                     aoi_drop_perc = 3,
#                                                     out_dir = dir_representative,
#                                                     new_sub_dir = FALSE)
# 
# 
# t1 <- test$df_not_represented
# t2 <- test2$df_not_represented
# t22 <- test2$df_represented
# 
# raster_cats |>
#   filter(EVT_GP == 685)
# 
# calc1 <- test$perc_area_not_represented
# calculated <- test2$perc_area_not_represented
# 
# raw <- test$df_included |>
#   dplyr::group_by(EVT_GP) |>
#   summarize(region_count = sum(region_count),
#             aoi_count = sum(aoi_count)) %>%
#   mutate(aoi_perc = (aoi_count / sum(.$region_count)) * 100)
# 
# 
# 
# u <- t2 |>
#   dplyr::select("EVT_GP", region_count, aoi_count, region_perc, aoi_perc) |>
#   dplyr::distinct() |>
#   dplyr::pull(region_count) |>
#   sum()
# 
# 
# tt <- analyze_categorical_cover(aoi_raster = taoi_rast,
#                                  larger_region_raster = tregion_rast,
#                                  raster_cat_df = raster_cats,
#                                  cat_base_column_name = "VALUE",
#                                  group = FALSE,
#                                  cat_group_column_name = NA)
# 
# ttt <- analyze_categorical_cover(aoi_raster = taoi_rast,
#                                       larger_region_raster = tregion_rast,
#                                       raster_cat_df = raster_cats,
#                                       cat_base_column_name = "EVT_GP",
#                                       group = FALSE,
#                                       cat_group_column_name = NA)
# 
# tttt <- analyze_categorical_cover(aoi_raster = taoi_rast,
#                                  larger_region_raster = tregion_rast,
#                                  raster_cat_df = raster_cats,
#                                  cat_base_column_name = "VALUE",
#                                  group = TRUE,
#                                  cat_group_column_name = "EVT_GP_N")




# OLD
# 
# 
# tic()
# dir_test <- here::here(dir_representative, "test2")
# dir_ensure(dir_test)
# all_region_results <- purrr::pmap(list(region_shape = split(region_polygons_merged, seq(nrow(region_polygons_merged))),
#                                        aoi_shape = split(areas_of_interest_merged, seq(nrow(areas_of_interest_merged))),
#                                        run_name = paste0("neon_domains_2",region_polygons_merged$DomainName)),
#                                   representative_categorical_cover_analysis,
#                                   raster = raster,
#                                   raster_cat_df = raster_cats,
#                                   cat_base_column_name = "VALUE",
#                                   region_drop_perc = 0,
#                                   aoi_drop_perc = 0.001,
#                                   drop_classes = NA,
#                                   drop_classes_column_name = NA,
#                                   out_rast_values = "PERC_COVER",
#                                   out_rast_type = "BOTH",
#                                   out_dir = dir_test,
#                                   new_sub_dir = TRUE)
# toc() #just under 4 hours
# 
# 
# # Create a dataframe with all percentages and export
# result_df <- purrr::map_dfr(all_region_results, ~ tibble(
#   region_name = .x$analysis_name,
#   perc_area_not_represented = .x$perc_area_not_represented
# ))
# readr::write_csv(result_df, here::here(dir_evt0001, "neon_domains_results.csv"))
# 
# 
# not_rep_tif_files <- list.files(dir_evt0001,
#                                 pattern = "not_rep",
#                                 full.names = TRUE,
#                                 recursive = TRUE)
# 
# 
# 
# 
# 
# 
# 
# tic()
# tmap_options(max.raster = c(plot = 1e8, view = 1e5))
# conus <- tigris::states(cb = TRUE) |>  # `cb = TRUE` for a simplified "cartographic boundary" version
#   dplyr::filter(!STUSPS %in% c("HI", "AK", "GU", "VI", "MP", "AS", "PR")) |>
#   sf::st_transform(crs = terra::crs(terra::rast(not_rep_tif_files[1])))
# 
# 
# # Loop through each raster file, simplify if needed, and add to the tmap object
# for (raster_path in not_rep_tif_files) {
# 
#   # Load the raster
#   r <- stars::read_stars(raster_path,
#                          proxy = TRUE)
#   
#   if(raster_path == not_rep_tif_files[1]) {
#     tm_plot <- 
#       tm_shape(region_polygons_merged |>
#                  sf::st_transform(terra::crs(terra::rast(not_rep_tif_files[1]))),
#                bbox = sf::st_bbox(conus)) +
#       tm_borders(col = "gray90", lwd = 1) +
#       tm_fill(col = "gray90") +
#       tmap::tm_shape(r,
#                                   bbox = sf::st_bbox(conus),
#                                   downsample = TRUE) +
#       tmap::tm_raster(palette = "YlOrRd",
#                       style = "cont",
#                       breaks = c(0, 15),
#                       legend.show = TRUE,
#                       title = "Unrepresented landscape\npercentage by class",
#                       legend.reverse = FALSE,
#                       legend.format = list(fun = function(x) paste0(x, "%")),
#                       legend.is.portrait = FALSE)
#   } else {
#     # Add the raster to the tmap object
#     tm_plot <- tm_plot +
#       tmap::tm_shape(r,
#                      bbox = sf::st_bbox(conus),
#                      downsample = TRUE) +
#       tmap::tm_raster(palette = "YlOrRd",
#                       style = "cont",
#                       breaks = c(0, 15),
#                       legend.show = FALSE)
#   }
# }
# 
# # Finalize the plot layout with the legend outside
# tm_plot <- tm_plot +
#   tm_shape(region_polygons_merged) +
#   tm_borders(col = "gray20",
#               lwd = 1) +
#   tm_fill(col = NA, alpha = 0) +
#   tm_shape(areas_of_interest_merged) +
#   tm_borders(col = "darkblue",
#               lwd = 1) +
#   tmap::tm_layout(legend.outside = FALSE,
#                   legend.position = c("left", "bottom"))
# 
# # Display the plot
# tmap::tmap_save(tm_plot, here::here(dir_figs, "testdownsample_big.jpeg"))
# toc() #100- 123 seconds with default max.raster; 









# 
# tic()
# conus <- tigris::states(cb = TRUE) |>  # `cb = TRUE` for a simplified "cartographic boundary" version
#   dplyr::filter(!STUSPS %in% c("HI", "AK", "GU", "VI", "MP", "AS", "PR")) |>
#   sf::st_transform(crs = terra::crs(terra::rast(not_rep_tif_files[1])))
# 
# # Loop through each raster file, simplify if needed, and add to the tmap object
# for (raster_path in not_rep_tif_files) {
#   
#   # Load the raster
#   r <- terra::rast(raster_path) |>
#     terra::aggregate(fact = 10, na.rm = TRUE)
#   
#   
#   if(raster_path == not_rep_tif_files[1]) {
#     tm_plot <- 
#       tm_shape(region_polygons_merged |>
#                  sf::st_transform(terra::crs(terra::rast(not_rep_tif_files[1]))),
#                bbox = sf::st_bbox(conus)) +
#       tm_borders(col = "gray90", lwd = 1) +
#       tm_fill(col = "gray90") +
#       tmap::tm_shape(r,
#                      bbox = sf::st_bbox(conus),
#                      downsample = FALSE) +
#       tmap::tm_raster(palette = "YlOrRd",
#                       style = "cont",
#                       breaks = c(0, 15),
#                       legend.show = TRUE,
#                       title = "Unrepresented landscape\npercentage by class",
#                       legend.reverse = FALSE,
#                       legend.format = list(fun = function(x) paste0(x, "%")),
#                       legend.is.portrait = FALSE)
#   } else {
#     # Add the raster to the tmap object
#     tm_plot <- tm_plot +
#       tmap::tm_shape(r,
#                      bbox = sf::st_bbox(conus),
#                      downsample = FALSE) +
#       tmap::tm_raster(palette = "YlOrRd",
#                       style = "cont",
#                       breaks = c(0, 15),
#                       legend.show = FALSE)
#   }
# }
# 
# # Finalize the plot layout with the legend outside
# tm_plot <- tm_plot +
#   tm_shape(region_polygons_merged) +
#   tm_borders(col = "gray20",
#              lwd = 1) +
#   tm_fill(col = NA, alpha = 0) +
#   tm_shape(areas_of_interest_merged) +
#   tm_borders(col = "darkblue",
#              lwd = 1) +
#   tmap::tm_layout(legend.outside = FALSE,
#                   legend.position = c("left", "bottom"))
# 
# # Display the plot
# tmap::tmap_save(tm_plot, here::here(dir_figs, "testaggregate10_big.jpeg"))
# toc() 
# 
# 



# # TESTING
# 
# 
# #Southern rockies
# region_shape <- region_polygons |>
#   dplyr::filter(US_L3NAME == "Southern Rockies") |>
#   dplyr::group_by(US_L3NAME) |>
#   dplyr::summarise(geometry = st_union(geometry)) |>
#   dplyr::ungroup()
# 
# aoi_shape <- areas_of_interest |>
#   dplyr::filter(siteID == "NIWO")
# 
# tshape <- areas_of_interest |>
#   dplyr::filter(siteID == "NIWO") |>
#   sf::st_transform(terra::crs(raster))
# 
# t <- raster |> terra::crop(tshape)
# 
# 
#   
# tic()
# results <- representative_categorical_cover_analysis(raster = raster,
#                                                      raster_cat_df = raster_cats,
#                                                      region_shape = region_shape,
#                                                      aoi_shape = aoi_shape,
#                                                      region_name = "TEST",
#                                                      cat_base_column_name = "VALUE",
#                                                      region_drop_perc = 0,
#                                                      aoi_drop_perc = 0.001,
#                                                      drop_classes = NA,
#                                                      drop_classes_column_name = NA,
#                                                      return_rast_values_as_landscape_perc = TRUE)
# toc() #on-campus run time:
# 
# 
# terra::writeRaster(results$raster_not_represented, here::here(dir_derived, "test_sr_notrep_perc.tif"))
# 
# 
# 
# 
# # Crop sub-regions for analysis
# print(paste0('Cropping to region', region_name))
# tic()
# larger_region_raster <- crop_careful_universal(raster = raster, vector = region_shape, mask = TRUE, verbose = TRUE) 
# toc()
# tic()
# aoi_raster <- crop_careful_universal(raster = larger_region_raster, vector = aoi_shape, mask = TRUE, verbose = TRUE)
# toc()
# 
# # Analyze
# landcover_analysis_output <- analyze_categorical_cover(aoi_raster = aoi_raster,
#                                                larger_region_raster = larger_region_raster,
#                                                raster_cat_df = raster_cats,
#                                                cat_base_column = "VALUE")
# 
# landcover_analysis_output2 <- analyze_categorical_cover(aoi_raster = aoi_raster,
#                                                        larger_region_raster = larger_region_raster,
#                                                        raster_cat_df = raster_cats,
#                                                        cat_base_column = "VALUE",
#                                                        group = TRUE,
#                                                        cat_group_column = "EVT_GP_N")
# 
# 
# 
# 
# tic()
# test <- representative_categorical_cover_analysis(raster = raster,
#                                                   raster_cat_df = raster_cats,
#                                                   region_shape = region_shape,
#                                                   aoi_shape = aoi_shape,
#                                                   cat_base_column_name = "VALUE",
#                                                   group = TRUE,
#                                                   cat_group_column_name = "EVT_GP_N",
#                                                   region_drop_perc = NA,
#                                                   drop_classes = NA,
#                                                   drop_classes_column_name = NA)
# toc()
# 
# 
# 
# 
# tic()
# test2 <- representative_categorical_cover_analysis(raster = raster,
#                                                   raster_cat_df = raster_cats,
#                                                   region_shape = region_shape,
#                                                   aoi_shape = aoi_shape,
#                                                   cat_base_column_name = "VALUE",
#                                                   group = TRUE,
#                                                   cat_group_column_name = "EVT_GP_N",
#                                                   region_drop_perc = 0.001,
#                                                   drop_classes = NA,
#                                                   drop_classes_column_name = NA)
# toc()
# 
# 
# 
# 
# tic()
# test3 <- representative_categorical_cover_analysis(raster = raster,
#                                                    raster_cat_df = raster_cats,
#                                                    region_shape = region_shape,
#                                                    aoi_shape = aoi_shape,
#                                                    cat_base_column_name = "VALUE",
#                                                    group = TRUE,
#                                                    cat_group_column_name = "EVT_GP_N",
#                                                    region_drop_perc = 0.001,
#                                                    drop_classes = c("Ponderosa Pine Forest, Woodland and Savanna",
#                                                                     "Big Sagebrush Shrubland and Steppe"),
#                                                    drop_classes_column_name = "EVT_GP_N")
# toc()
# 
# 
# 
# 
# 
# tic()
# test4 <- representative_categorical_cover_analysis(raster = raster,
#                                                    raster_cat_df = raster_cats,
#                                                    region_shape = region_shape,
#                                                    aoi_shape = aoi_shape,
#                                                    cat_base_column_name = "VALUE",
#                                                    region_drop_perc = 0,
#                                                    aoi_drop_perc = 0,
#                                                    drop_classes = NA,
#                                                    drop_classes_column_name = NA)
# toc()
# 
# terra::plot(test4$raster_represented)
# terra::plot(test4$raster_not_represented)
# 
# terra::writeRaster(test4$lc_analysis_raster, here::here(dir_derived, "test.tif"), overwrite = TRUE)
# 
# 
# freq(test4$lc_analysis_raster)
# 
# 
# sum(test4$df_represented$region_count)
# 





# Older function versions

# save_rasters <- function(raster, df, type, out_dir, clean_run_name, 
#                          out_rast_values, perc_digits, raster_return, 
#                          cat_base_column_name) {  
#   
#   base_path <- here::here(out_dir, paste0(clean_run_name, "_", type))
#   raster_list <- list()
#   
#   for (value_type in out_rast_values) {
#     
#     # If RAW, directly return/write the clipped raster without reclassification
#     if (value_type == "RAW") {
#       raster_raw <- raster  # Just retain the original values
#       
#       if ("MEMORY" %in% raster_return) {
#         raster_list[[value_type]] <- raster_raw
#       }
#       if ("WRITE" %in% raster_return) {
#         output_file <- paste0(base_path, "_raw.tif")
#         terra::writeRaster(raster_raw, output_file, overwrite = TRUE, gdal = c("COMPRESS=DEFLATE"))
#       }
#       
#       next  # Skip to the next raster type
#     }
#     
#     # Determine the appropriate metric column
#     metric_column <- switch(value_type,
#                             "PERC_COVER_AOI" = "aoi_perc",
#                             "PERC_COVER_REGION" = "region_perc",
#                             stop(glue::glue("Invalid out_rast_values option: {value_type}")))
#     
#     # Ensure the necessary columns exist
#     if (!cat_base_column_name %in% colnames(df)) {
#       stop(glue::glue("Error: Column '{cat_base_column_name}' not found in the dataframe."))
#     }
#     
#     if (!metric_column %in% colnames(df)) {
#       stop(glue::glue("Error: Column '{metric_column}' not found in the dataframe."))
#     }
#     
#     # Apply rounding if needed
#     df <- df |>
#       dplyr::mutate(!!metric_column := if (!is.na(perc_digits)) round(.data[[metric_column]], perc_digits) else .data[[metric_column]])
#     
#     # Create the classification matrix
#     reclass_matrix <- df |>
#       dplyr::select(all_of(cat_base_column_name), all_of(metric_column)) |> 
#       as.matrix()
#     
#     # Classify the raster
#     raster_reclassified <- terra::classify(raster, reclass_matrix)
#     
#     if ("MEMORY" %in% raster_return) {
#       raster_list[[value_type]] <- raster_reclassified
#     }
#     if ("WRITE" %in% raster_return) {
#       output_file <- paste0(base_path, "_", tolower(value_type), ".tif")
#       terra::writeRaster(raster_reclassified, output_file, overwrite = TRUE, gdal = c("COMPRESS=DEFLATE"))
#     }
#   }
#   
#   if ("MEMORY" %in% raster_return) {
#     return(raster_list)
#   }
#   if("WRITE" %in% raster_return) {
#     return(invisible(NULL))
#   }
# }



# representative_categorical_cover_analysis <- function(raster,
#                                                       raster_cat_df,
#                                                       region_shape,
#                                                       aoi_shape,
#                                                       run_name = "NotProvided",
#                                                       cat_base_column_name, 
#                                                       min_aoi_coverage = NA,
#                                                       min_region_coverage = NA,
#                                                       drop_classes = NA,
#                                                       drop_classes_column_name = NA,
#                                                       out_rast_values = c("RAW", "PERC_COVER_AOI", "PERC_COVER_REGION"),
#                                                       out_rast_type = c("REP", "NOT_REP", "FULL"),
#                                                       out_dir = "",
#                                                       new_sub_dir = FALSE,
#                                                       perc_digits = NA,
#                                                       raster_return = "MEMORY") {
#   
#   print(paste0("Operating on run: ", run_name))
#   
#   # Treat NA min_aoi_coverage as zero
#   if (is.na(min_aoi_coverage)) {
#     min_aoi_coverage <- 0
#   }
#   # Ensure min_region_coverage is not NA (assuming default of 0 if not provided)
#   if (is.na(min_region_coverage)) {
#     min_region_coverage <- 0
#   }
#   
#   # Validate input parameters
#   valid_rast_values <- c("RAW", "PERC_COVER_AOI", "PERC_COVER_REGION")
#   valid_rast_types <- c("REP", "NOT_REP", "FULL", "NONE")
#   valid_raster_return <- c("MEMORY", "WRITE")
#   
#   if (!all(out_rast_values %in% valid_rast_values)) {
#     stop("Invalid out_rast_values. Must be one or more of: 'RAW', 'PERC_COVER_AOI', 'PERC_COVER_REGION'.")
#   }
#   
#   if (!all(out_rast_type %in% valid_rast_types)) {
#     stop("Invalid out_rast_type. Must be one or more of: 'REP', 'NOT_REP', 'FULL', 'NONE'.")
#   }
#   
#   if (!all(raster_return %in% valid_raster_return)) {
#     stop("Invalid raster_return. Must be one or more of: 'MEMORY', 'WRITE'.")
#   }
#   
#   if (!cat_base_column_name %in% names(raster_cat_df)) {
#     stop("cat_base_column_name must be a column in raster_cat_df")
#   }
#   
#   print(paste0("Operating on run: ", run_name))
#   
#   # Set up output directory
#   clean_run_name <- gsub(" ", "", run_name)
#   clean_aoi_dp <- gsub("\\.", "", as.character(min_aoi_coverage))
#   clean_region_dp <- gsub("\\.", "", as.character(min_region_coverage))
#   clean_run_name <- paste(clean_run_name, "_aoi", clean_aoi_dp, "_region", clean_region_dp, sep = "")
#   
#   if (new_sub_dir) {
#     out_dir <- here::here(out_dir, clean_run_name)
#     dir_ensure(out_dir)
#   }
#   
#   # Crop to region and AOI
#   print("Cropping to region")
#   larger_region_cover <- crop_careful_universal(raster, region_shape, mask = TRUE)
#   print("Cropping to AOI")
#   aoi_cover <- crop_careful_universal(larger_region_cover, aoi_shape, mask = TRUE)
#   
#   # Perform categorical cover analysis
#   landcover_analysis_output_raw <- analyze_categorical_cover(aoi_cover, larger_region_cover, raster_cat_df, cat_base_column_name)
#   
#   # Process drop classes and thresholding
#   landcover_analysis_output_included <- landcover_analysis_output_raw
#   if (!is.na(min_region_coverage)) {
#     landcover_analysis_output_included <- landcover_analysis_output_included |> dplyr::filter(region_perc > min_region_coverage)
#   }
#   if (length(drop_classes) > 0 && !all(is.na(drop_classes))) {
#     landcover_analysis_output_included <- landcover_analysis_output_included |> 
#       dplyr::filter(!(.data[[drop_classes_column_name]] %in% drop_classes))
#   }
#   
#   # Split into represented and not represented classes
#   df_represented <- landcover_analysis_output_included |> dplyr::filter(aoi_perc > min_aoi_coverage)
#   df_not_represented <- landcover_analysis_output_included |> dplyr::filter(aoi_perc <= min_aoi_coverage)
#   
#   # Compute percent not represented
#   perc_area_not_represented <- (sum(df_not_represented$region_count) / sum(landcover_analysis_output_included$region_count)) * 100
#   
#   # 🛠️ **Create filtered rasters for REP & NOT_REP cases**
#   raster_represented <- terra::classify(larger_region_cover, 
#                                         as.matrix(df_represented[, c(cat_base_column_name, cat_base_column_name)]), 
#                                         others = NA)
#   
#   raster_not_represented <- terra::classify(larger_region_cover, 
#                                             as.matrix(df_not_represented[, c(cat_base_column_name, cat_base_column_name)]), 
#                                             others = NA)
#   
#   # Save rasters
#   raster_outputs <- list()
#   if ("FULL" %in% out_rast_type) {
#     raster_outputs$full <- save_rasters(larger_region_cover, landcover_analysis_output_raw, "full",
#                                         out_dir, clean_run_name, out_rast_values, perc_digits, raster_return, cat_base_column_name)
#   }
#   if ("REP" %in% out_rast_type) {
#     raster_outputs$rep <- save_rasters(raster_represented, df_represented, "rep",
#                                        out_dir, clean_run_name, out_rast_values, perc_digits, raster_return, cat_base_column_name)
#   }
#   if ("NOT_REP" %in% out_rast_type) {
#     raster_outputs$not_rep <- save_rasters(raster_not_represented, df_not_represented, "not_rep",
#                                            out_dir, clean_run_name, out_rast_values, perc_digits, raster_return, cat_base_column_name)
#   }
#   
#   return(list(analysis_name = run_name,
#               df_raw = landcover_analysis_output_raw,
#               df_included = landcover_analysis_output_included,
#               df_represented = df_represented,
#               df_not_represented = df_not_represented,
#               perc_area_not_represented = perc_area_not_represented,
#               rasters = if ("MEMORY" %in% raster_return) raster_outputs else NULL))
# }



# representative_categorical_cover_analysis <- function(raster,
#                                                       raster_cat_df,
#                                                       region_shape,
#                                                       aoi_shape,
#                                                       run_name = "NotProvided",
#                                                       cat_base_column_name, 
#                                                       min_aoi_coverage = NA,
#                                                       min_region_coverage = NA,
#                                                       drop_classes = NA,
#                                                       drop_classes_column_name = NA,
#                                                       out_rast_values = c("RAW", "PERC_COVER_AOI", "PERC_COVER_REGION"),
#                                                       out_rast_type = c("REP", "NOT_REP", "FULL"),
#                                                       out_dir = "",
#                                                       new_sub_dir = FALSE,
#                                                       perc_digits = NA,
#                                                       raster_return = "MEMORY") {
#   
#   print(paste0("Operating on run: ", run_name))
#   
#   # Ensure min_aoi_coverage and min_region_coverage are within valid ranges
#   min_aoi_coverage <- ifelse(is.na(min_aoi_coverage) | min_aoi_coverage < 0, 0, min(min_aoi_coverage, 100))
#   min_region_coverage <- ifelse(is.na(min_region_coverage) | min_region_coverage < 0, 0, min(min_region_coverage, 100))
#   
#   # Validate input parameters
#   valid_rast_values <- c("RAW", "PERC_COVER_AOI", "PERC_COVER_REGION")
#   valid_rast_types <- c("REP", "NOT_REP", "FULL", "NONE")
#   valid_raster_return <- c("MEMORY", "WRITE")
#   
#   if (!all(out_rast_values %in% valid_rast_values)) {
#     stop("Invalid out_rast_values. Must be one or more of: 'RAW', 'PERC_COVER_AOI', 'PERC_COVER_REGION'.")
#   }
#   
#   if (!all(out_rast_type %in% valid_rast_types)) {
#     stop("Invalid out_rast_type. Must be one or more of: 'REP', 'NOT_REP', 'FULL', 'NONE'.")
#   }
#   
#   if (!all(raster_return %in% valid_raster_return)) {
#     stop("Invalid raster_return. Must be one or more of: 'MEMORY', 'WRITE'.")
#   }
#   
#   if (!cat_base_column_name %in% names(raster_cat_df)) {
#     stop("cat_base_column_name must be a column in raster_cat_df")
#   }
#   
#   print(paste0("Operating on run: ", run_name))
#   
#   # Set up output directory
#   clean_run_name <- gsub(" ", "", run_name)
#   clean_aoi_dp <- gsub("\\.", "", as.character(min_aoi_coverage))
#   clean_region_dp <- gsub("\\.", "", as.character(min_region_coverage))
#   clean_run_name <- paste(clean_run_name, "_aoi", clean_aoi_dp, "_region", clean_region_dp, sep = "")
#   
#   if (new_sub_dir) {
#     out_dir <- here::here(out_dir, clean_run_name)
#     dir_ensure(out_dir)
#   }
#   
#   # Crop to region and AOI
#   print("Cropping to region")
#   larger_region_cover <- crop_careful_universal(raster, region_shape, mask = TRUE)
#   print("Cropping to AOI")
#   aoi_cover <- crop_careful_universal(larger_region_cover, aoi_shape, mask = TRUE)
#   
#   # Perform categorical cover analysis
#   landcover_analysis_output_raw <- analyze_categorical_cover(aoi_cover, larger_region_cover, raster_cat_df, cat_base_column_name)
#   
#   # Determine maximum observed percentages
#   max_region_perc <- max(landcover_analysis_output_raw$region_perc, na.rm = TRUE)
#   max_aoi_perc <- max(landcover_analysis_output_raw$aoi_perc, na.rm = TRUE)
#   
#   # Adjust extreme min_region_coverage and min_aoi_coverage values
#   if (min_region_coverage > max_region_perc) {
#     warning(glue::glue("min_region_coverage ({min_region_coverage}%) exceeds all observed region percentages. Adjusting to {max_region_perc}%."))
#     min_region_coverage <- max_region_perc
#   }
#   
#   if (min_aoi_coverage > max_aoi_perc) {
#     warning(glue::glue("min_aoi_coverage ({min_aoi_coverage}%) exceeds all observed AOI percentages. Adjusting to {max_aoi_perc}%."))
#     min_aoi_coverage <- max_aoi_perc
#   }
#   
#   # Process drop classes and thresholding
#   landcover_analysis_output_included <- landcover_analysis_output_raw
#   if (!is.na(min_region_coverage)) {
#     landcover_analysis_output_included <- landcover_analysis_output_included |> dplyr::filter(region_perc > min_region_coverage)
#   }
#   if (length(drop_classes) > 0 && !all(is.na(drop_classes))) {
#     landcover_analysis_output_included <- landcover_analysis_output_included |> 
#       dplyr::filter(!(.data[[drop_classes_column_name]] %in% drop_classes))
#   }
#   
#   # Split into represented and not represented classes
#   df_represented <- landcover_analysis_output_included |> dplyr::filter(aoi_perc > min_aoi_coverage)
#   df_not_represented <- landcover_analysis_output_included |> dplyr::filter(aoi_perc <= min_aoi_coverage)
#   
#   # Compute percent not represented
#   perc_area_not_represented <- (sum(df_not_represented$region_count) / sum(landcover_analysis_output_included$region_count)) * 100
#   
#   # Create filtered rasters for REP & NOT_REP cases
#   raster_represented <- terra::classify(larger_region_cover, 
#                                         as.matrix(df_represented[, c(cat_base_column_name, cat_base_column_name)]), 
#                                         others = NA)
#   
#   raster_not_represented <- terra::classify(larger_region_cover, 
#                                             as.matrix(df_not_represented[, c(cat_base_column_name, cat_base_column_name)]), 
#                                             others = NA)
#   
#   # Save rasters
#   raster_outputs <- list()
#   if ("FULL" %in% out_rast_type) {
#     raster_outputs$full <- save_rasters(larger_region_cover, landcover_analysis_output_raw, "full",
#                                         out_dir, clean_run_name, out_rast_values, perc_digits, raster_return, cat_base_column_name)
#   }
#   if ("REP" %in% out_rast_type) {
#     raster_outputs$rep <- save_rasters(raster_represented, df_represented, "rep",
#                                        out_dir, clean_run_name, out_rast_values, perc_digits, raster_return, cat_base_column_name)
#   }
#   if ("NOT_REP" %in% out_rast_type) {
#     raster_outputs$not_rep <- save_rasters(raster_not_represented, df_not_represented, "not_rep",
#                                            out_dir, clean_run_name, out_rast_values, perc_digits, raster_return, cat_base_column_name)
#   }
#   
#   return(list(analysis_name = run_name,
#               df_raw = landcover_analysis_output_raw,
#               df_included = landcover_analysis_output_included,
#               df_represented = df_represented,
#               df_not_represented = df_not_represented,
#               perc_area_not_represented = perc_area_not_represented,
#               rasters = if ("MEMORY" %in% raster_return) raster_outputs else NULL))
# }




# 
# #out_rast_values = "BOTH", "PERC_COVER", or "RAW"
# #out_rast_type = "BOTH", "REP", "NOT_REP", or "NONE"
# representative_categorical_cover_analysis <- function(raster,
#                                                       raster_cat_df,
#                                                       region_shape,
#                                                       aoi_shape,
#                                                       run_name = "NotProvided",
#                                                       cat_base_column_name, 
#                                                       aoi_drop_perc = NA,
#                                                       region_drop_perc = NA,
#                                                       drop_classes = NA,
#                                                       drop_classes_column_name = NA,
#                                                       out_rast_values = "BOTH",
#                                                       out_rast_type = "BOTH",
#                                                       out_dir = "",
#                                                       new_sub_dir = FALSE) {
#   
#   print(paste0("Operating on run: ", run_name))
#   
#   # Validate inputs
#   if(!out_rast_values %in% c("BOTH", "PERC_COVER", "RAW")) {
#     stop("Invalid value for 'out_rast_values'. Must be one of: 'BOTH', 'PERC_COVER', 'RAW'.")
#   }
#   
#   if(!out_rast_type %in% c("BOTH", "REP", "NOT_REP", "NONE")) {
#     stop("Invalid value for 'out_rast_values'. Must be one of: 'BOTH', 'REP', 'NOT_REP', 'NONE'.")
#   }
#   
#   if(run_name == "NotProvided") {
#     warning("You have not provided a run_name; 'NotProvided' will be used")
#   }
#   
#   if(!cat_base_column_name %in% names(raster_cat_df)) {
#     stop("cat_base_column_name must be one of the column names in raster_cat_df")
#   }
#   
#   
#   #Setup output directories
#   clean_run_name <- run_name %>%
#     gsub(" ", "", .) %>%
#     gsub("/", "_", .) %>%
#     gsub("\\.", "_", .)
#   clean_aoi_dp <- gsub("\\.", "", as.character(aoi_drop_perc))
#   clean_region_dp <- gsub("\\.", "", as.character(region_drop_perc))
#   clean_run_name <- paste(clean_run_name, "_adp", clean_aoi_dp, "_rdp", clean_region_dp, sep = "")
#   
#   if(new_sub_dir) {
#     out_dir <- here::here(out_dir, clean_run_name)
#     dir_ensure(out_dir)
#   }
#   
#   # Crop sub-regions for analysis
#   print('Cropping to region')
#   larger_region_cover <- crop_careful_universal(raster = raster, vector = region_shape, mask = TRUE, verbose = FALSE) 
#   print(paste0('Cropping to sub-region aoi'))
#   aoi_cover <- crop_careful_universal(raster = larger_region_cover, vector = aoi_shape, mask = TRUE, verbose = FALSE)
#   
#   # Analyze
#   landcover_analysis_output_raw <- analyze_categorical_cover(aoi_raster = aoi_cover,
#                                                              larger_region_raster = larger_region_cover,
#                                                              raster_cat_df = raster_cat_df,
#                                                              cat_base_column = cat_base_column_name)
#   landcover_analysis_output_included <- landcover_analysis_output_raw
#   
#   
#   
#   # Remove any classes that are below the regional drop percentage, if specified
#   # This is to keep data clean for rasters with many categories that are not common on the landscape
#   if(!is.na(region_drop_perc)) {
#     landcover_analysis_output_included <- landcover_analysis_output_included |>
#       dplyr::filter(region_perc > region_drop_perc)
#   }
#   
#   # Remove any specifically called out classes
#   if (length(drop_classes) > 0 && !all(is.na(drop_classes))) {
#     drop_classes_col_sym <- rlang::sym(drop_classes_column_name)
#     landcover_analysis_output_included <- landcover_analysis_output_included |>
#       dplyr::filter(!(.data[[drop_classes_column_name]] %in% drop_classes))
#   }
#   
#   
#   
#   # Remove classes that are below a certain AOI percentage (i.e. that are not adequately represented within the aoi)
#   if(!is.na(aoi_drop_perc)) {
#     df_represented <- landcover_analysis_output_included |>
#       dplyr::filter(aoi_perc > aoi_drop_perc)
#     df_not_represented <- landcover_analysis_output_included |>
#       dplyr::filter(aoi_perc <= aoi_drop_perc)
#   }
#   
#   # OLD VERSION
#   # #Get percentage of area not represented (only taking into account areas included)
#   # perc_area_not_represented <- (sum(df_not_represented$region_count) / sum(landcover_analysis_output_included$region_count)) * 100
#   
#   
#   # NEW VERSION
#   not_rep_count <- df_not_represented |>
#     dplyr::select(cat_base_column_name, region_count, aoi_count, region_perc, aoi_perc) |>
#     dplyr::distinct() |>
#     dplyr::pull(region_count) |>
#     sum()
#   
#   all_count <- landcover_analysis_output_included |>
#     dplyr::select(cat_base_column_name, region_count, aoi_count, region_perc, aoi_perc) |>
#     dplyr::distinct() |>
#     dplyr::pull(region_count) |>
#     sum()
#   
# 
#   perc_area_not_represented <- (not_rep_count / all_count) * 100
#   #
#   
#   
#   
#   # Generate new raster data requested
#   
#   #Not represented areas
#   if(out_rast_type == "BOTH" | out_rast_type == "NOT_REP") {
#     print('Generating new rasters: Raster not represented')
#     raster_not_represented <- keep_tif_values_in_df(raster = larger_region_cover, df = df_not_represented)
#     
#     if(out_rast_values == "RAW" | out_rast_values == "BOTH") {
#       terra::writeRaster(raster_not_represented,
#                          here::here(out_dir, paste0(clean_run_name, "_not_rep_raw.tif")),
#                          overwrite = TRUE,
#                          gdal = c("COMPRESS=DEFLATE"))
#     }
#     
#     if(out_rast_values == "BOTH" | out_rast_values == "PERC_COVER") {
#       print("Reclassifying output raster to use landscape percentage")
#       not_rep_classify <- df_not_represented |>
#         dplyr::select({{cat_base_column_name}}, region_perc) |>
#         as.matrix()
#       raster_not_represented <- raster_not_represented |>
#         terra::classify(not_rep_classify)
#       
#       terra::writeRaster(raster_not_represented,
#                          here::here(out_dir, paste0(clean_run_name, "_not_rep_perc_cover.tif")),
#                          overwrite = TRUE,
#                          gdal = c("COMPRESS=DEFLATE"))
#     }
#     
#     rm(raster_not_represented)
#     gc()
#   }
#     
#   # represented areas
#   if(out_rast_type == "BOTH" | out_rast_type == "REP") {
#     
#     print('Generating new rasters: Raster represented')
#     raster_represented <- keep_tif_values_in_df(raster = larger_region_cover, df = df_represented)
#     
#     if(out_rast_values == "RAW" | out_rast_values == "BOTH") {
#       terra::writeRaster(raster_represented,
#                          here::here(out_dir, paste0(clean_run_name, "_rep_raw.tif")),
#                          overwrite = TRUE,
#                          gdal = c("COMPRESS=DEFLATE"))
#     }
#     
#     if(out_rast_values == "BOTH" | out_rast_values == "PERC_COVER") {
#       print("Reclassifying output raster to use landscape percentage")
#       
#       rep_classify <- df_represented |>
#         dplyr::select({{cat_base_column_name}}, region_perc) |>
#         as.matrix()
#       raster_represented <- raster_represented |>
#         terra::classify(rep_classify)
#       
#       terra::writeRaster(raster_represented,
#                          here::here(out_dir, paste0(clean_run_name, "_rep_perc_cover.tif")),
#                          overwrite = TRUE,
#                          gdal = c("COMPRESS=DEFLATE"))
#     }
#     
#     rm(raster_represented)
#     gc()
#   
#   }
#   
#   # no rasters
#   if(out_rast_type == "NONE") {
#     print("You have not requested a written output raster, returning only in-memory non-spatial data")
#   }
#   
#   return(list(analysis_name = run_name,
#               df_raw = landcover_analysis_output_raw,
#               df_included = landcover_analysis_output_included,
#               df_represented = df_represented,
#               df_not_represented = df_not_represented,
#               perc_area_not_represented = perc_area_not_represented))
# }

